Architektura
Vzhledem ke skutečnosti, že projekt byl původně navrhován pro běh v kontejneru OSGi, je aplikace navrhována formou balíčků (bundlů), do kterých budou stěžejní části programu rozděleny. Výhodou tohoto řešení měla být možnost plného využití OSGi kontejneru a zejména funkce dynamického přidávání a odebírání bundlů za běhu bez potřeby restartování aplikace.
Projekt však nedosáhl takové úrovně, aby této funkcionality bylo využito. Navíc OSGi framework není v současné době příliš využíván a není tak moc dobře dokumentován z hlediska uživatelských rad. Další nevýhodou je nízkoúrovňové napojení na databázi přes JDBC a složitější programování prezentační vrstvy za využití některého z embedded webových serverů (Netty, Jetty).
Rozhodli jsme se tedy přejít na architekturu technologie Java EE, která má všechny tyto naše požadavky řešené a navíc poskytuje jednoduché rozhraní k Dependency Injection (v OSGi bychom museli explicitně využít například Spring). Architektura bundlů však při technologickém přechodu zůstala zachována a při zpětném pohledu se stává spíše na obtíž, protože je nutná složitější konfigurace sestavovacího nástroje a je potřeba využít zastaralejší (nebo alespoň v současnosti méně používaný) sestavovací způsob Enterprise Archive (EAR). Dnes se již díky skutečnosti, že aplikační servery využívají EJB Lite kontejner používá častěji Webový archív (WAR). 

Grafy v databázi
Zásadní chybou návrhu současného řešení je skutečnost, že grafy se ukládají do databáze přímo ve formě zpracovaného výstupu pro uživatele. Zpracování tak probíhá nyní na straně serveru. Mnohem lepší se jeví uložit celou reprezentaci prošlého webu do databáze a poslat ho v určité formě uživateli, aby mohl graf vytvořit na své straně pomocí javascriptových knihoven. Odpadla by tak nutnost zpracování grafů na straně serveru a uživatel by navíc na své straně mohl dělat různé úpravy a transformace grafu podle svých potřeb (pokud to JS knihovna nabídne). Nevýhodou je složitější uložení instancí grafů do databáze a domluva přenosového protokolu pro přenos grafu (nejspíš JSON či XML)

Reprezentace chybových zpráv
V současné době jsou informativní a chybové zprávy určené pro uživatele reprezentovány hierarchií objektů, které se následně musí mapovat do databáze a zpět. Ačkoliv se tento návrh zdá být jednoduchý a jasný, časem jsme zjistili, že se jedná o velice špatné řešení, kde jakákoliv další úprava se zdá být nemyslitelná. Pokud bychom něco podobného navrhovali příště, bylo by nutné od začátku uvažovat možnost mnohaatributového filtrování, řazení a stránkování zpráv.

Web crawler
Crawler na procházení webů bylo předem velice složité navrhnout a přestože návrh byl téměř dokonalý, narazili jsme na pár problémů, které tento návrh musely velice silně ovlivnit. Například díky CSSRedundancyCheckeru jsme potřebovali, aby kaskádové styly dorazili dríve, než samotné stránky, ke kterým je přiřazen, nebo alespoň zajistit, aby vůbec dorazil. Všechny tyto změny bylo složité aplikovat, protože na ně návrh nebyl stavěny a nikoho nenapadlo o těchto problémech uvažovat.
